/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BrowserFavoritesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = require('path');

var DEFAULT_SETTINGS = {
    outputFolderPath: 'Browser Favorites'
};

class FileUploadModal extends import_obsidian.Modal {
    constructor(app, onFileUpload) {
        super(app);
        this.onFileUpload = onFileUpload;
    }

    onOpen() {
        const {contentEl, titleEl} = this;

        titleEl.setText('Import Browser Bookmarks');
        
        const instructions = contentEl.createEl("div");
        instructions.createEl("p", {
            text: "How to export your bookmarks:",
            cls: "browser-favorites-header"
        });
        
        const browserInstructions = instructions.createEl("div", {
            cls: "browser-favorites-instructions"
        });
        
        browserInstructions.createEl("p", {
            text: "Chrome: Bookmarks Manager (Ctrl+Shift+O) → ⋮ → Export bookmarks"
        });
        browserInstructions.createEl("p", {
            text: "Firefox: Bookmarks → Manage Bookmarks → Import and Backup → Export Bookmarks to HTML"
        });
        browserInstructions.createEl("p", {
            text: "Edge: Settings → Favorites → ⋮ → Export favorites"
        });

        const fileInputContainer = contentEl.createEl("div", {
            cls: "browser-favorites-file-input"
        });

        const fileInputButton = fileInputContainer.createEl("button", {
            text: "Select Bookmarks HTML File",
            cls: "browser-favorites-file-button"
        });

        const fileInput = fileInputContainer.createEl("input", {
            attr: {
                type: "file",
                accept: ".html,.htm",
                style: "display: none;"
            }
        });

        const fileNameDisplay = fileInputContainer.createEl("div", {
            cls: "browser-favorites-filename"
        });

        fileInput.addEventListener("change", () => {
            const file = fileInput.files[0];
            if (file) {
                fileNameDisplay.setText(file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    if (typeof content === 'string') {
                        this.onFileUpload(content);
                        this.close();
                    } else {
                        new import_obsidian.Notice("Unable to read file content. Please make sure it's a text file.");
                    }
                };
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    new import_obsidian.Notice("Error reading file. Please try again.");
                };
                reader.readAsText(file);
            }
        });

        fileInputButton.addEventListener("click", () => {
            fileInput.click();
        });

        new import_obsidian.Setting(contentEl)
            .addButton(button => {
                button.setButtonText("Cancel")
                    .onClick(() => {
                        this.close();
                    });
            });
    }

    onClose() {
        const {contentEl} = this;
        contentEl.empty();
    }
}

class BrowserFavoritesPlugin extends import_obsidian.Plugin {
    async onload() {
        await this.loadSettings();

        this.addRibbonIcon('browser', 'Browser Favorites', () => {
            new import_obsidian.Notice('This plugin cannot directly access browser bookmarks due to security restrictions. Please export your bookmarks as HTML and use the import functionality.');
        });

        this.addSettingTab(new BrowserFavoritesSettingTab(this.app, this));

        this.addCommand({
            id: 'import-browser-bookmarks',
            name: 'Import Browser Bookmarks',
            callback: async () => {
                new FileUploadModal(this.app, (content) => {
                    this.importBookmarks(content);
                }).open();
            }
        });
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    categorize(title) {
        const lowerTitle = title.toLowerCase();
        if (lowerTitle.includes('news'))
            return 'News';
        if (lowerTitle.includes('wiki'))
            return 'Reference';
        if (lowerTitle.includes('blog'))
            return 'Blogs';
        return 'General';
    }

    async readExistingBookmarks(category) {
        const outputFolderPath = import_obsidian.normalizePath(this.settings.outputFolderPath);
        const fileName = import_obsidian.normalizePath(path.join(outputFolderPath, `${category}.md`));
        const file = this.app.vault.getAbstractFileByPath(fileName);
        
        if (!file) return new Set();

        const content = await this.app.vault.read(file);
        const urlRegex = /\[(.*?)\]\((https?:\/\/[^\s\)]+)\)/g;
        const existingUrls = new Set();
        
        let match;
        while ((match = urlRegex.exec(content)) !== null) {
            existingUrls.add(match[2]);
        }
        
        return existingUrls;
    }

    async importBookmarks(htmlContent) {
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const links = doc.querySelectorAll('a');
            
            if (links.length === 0) {
                new import_obsidian.Notice('No bookmarks found in the file. Please make sure you uploaded a browser bookmarks export file.');
                return;
            }

            const bookmarks = {};
            const stats = {
                total: 0,
                new: 0,
                existing: 0
            };

            for (const link of links) {
                const href = link.getAttribute('href');
                if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
                    stats.total++;
                    const title = link.textContent?.trim() || 'Untitled';
                    const category = this.categorize(title);
                    if (!bookmarks[category]) {
                        bookmarks[category] = new Set();
                    }
                    bookmarks[category].add({ title: title, url: href });
                }
            }

            if (stats.total === 0) {
                new import_obsidian.Notice('No valid bookmarks found in the file. Please make sure you uploaded a browser bookmarks export file.');
                return;
            }

            for (const category in bookmarks) {
                const existingUrls = await this.readExistingBookmarks(category);
                const newBookmarks = Array.from(bookmarks[category]).filter(bookmark => !existingUrls.has(bookmark.url));
                
                stats.new += newBookmarks.length;
                stats.existing += bookmarks[category].size - newBookmarks.length;
                
                if (newBookmarks.length > 0) {
                    await this.appendBookmarks(category, newBookmarks);
                }
            }

            new import_obsidian.Notice(
                `Import complete!\nTotal links: ${stats.total}\nNew: ${stats.new}\nExisting: ${stats.existing}`
            );
        } catch (error) {
            console.error('Error processing bookmarks:', error);
            console.error('HTML Content preview:', htmlContent.substring(0, 200) + '...');
            new import_obsidian.Notice('Error processing bookmarks. Please check the console for details.');
        }
    }

    async appendBookmarks(category, newBookmarks) {
        const outputFolderPath = import_obsidian.normalizePath(this.settings.outputFolderPath);

        if (!this.app.vault.getAbstractFileByPath(outputFolderPath)) {
            await this.app.vault.createFolder(outputFolderPath);
        }

        const fileName = import_obsidian.normalizePath(path.join(outputFolderPath, `${category}.md`));
        const file = this.app.vault.getAbstractFileByPath(fileName);
        
        let content = '';
        if (file) {
            content = await this.app.vault.read(file);
            content += '\n';
        } else {
            content = `# ${category} Bookmarks\n\n`;
        }

        newBookmarks.forEach(bookmark => {
            content += `- [${bookmark.title}](${bookmark.url})\n`;
        });

        if (file) {
            await this.app.vault.modify(file, content);
        } else {
            await this.app.vault.create(fileName, content);
        }
    }
}

class BrowserFavoritesSettingTab extends import_obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display() {
        const {containerEl} = this;
        containerEl.empty();
        containerEl.createEl('h2', {text: 'Browser Favorites Settings'});
        
        new import_obsidian.Setting(containerEl)
            .setName('Output folder')
            .setDesc('Where to store the imported bookmarks')
            .addText(text => text
                .setPlaceholder('Browser Favorites')
                .setValue(this.plugin.settings.outputFolderPath)
                .onChange(async (value) => {
                    this.plugin.settings.outputFolderPath = value;
                    await this.plugin.saveSettings();
                }));
    }
}
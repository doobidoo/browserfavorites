/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BrowserFavoritesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var PLUGIN_VERSION = "1.0.10";
var BOOKMARK_TABLE_HEADERS = {
  columns: [
    "Title",
    "URL",
    "Tags",
    "Added",
    "Description",
    "Last Check",
    "Status"
  ],
  get header() {
    const headerRow = `| ${this.columns.join(" | ")} |`;
    const separatorRow = `|${this.columns.map(() => "------").join("|")}|`;
    return `${headerRow}
${separatorRow}
`;
  }
};
var DEFAULT_SETTINGS = {
  outputFolderPath: "Browser Favorites",
  checkAccessibility: true
};
var FileUploadModal = class extends import_obsidian.Modal {
  constructor(app, onFileUpload) {
    super(app);
    this.onFileUpload = onFileUpload;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Import Browser Bookmarks");
    const instructions = contentEl.createEl("div");
    instructions.createEl("p", {
      text: "How to export your bookmarks:",
      cls: "browser-favorites-header"
    });
    const browserInstructions = instructions.createEl("div", {
      cls: "browser-favorites-instructions"
    });
    browserInstructions.createEl("p", {
      text: "Chrome: Bookmarks Manager (Ctrl+Shift+O) \u2192 \u22EE \u2192 Export bookmarks"
    });
    browserInstructions.createEl("p", {
      text: "Firefox: Bookmarks \u2192 Manage Bookmarks \u2192 Import and Backup \u2192 Export Bookmarks to HTML"
    });
    browserInstructions.createEl("p", {
      text: "Edge: Settings \u2192 Favorites \u2192 \u22EE \u2192 Export favorites"
    });
    const fileInputContainer = contentEl.createEl("div", {
      cls: "browser-favorites-file-input"
    });
    const fileInputButton = fileInputContainer.createEl("button", {
      text: "Select Bookmarks HTML File",
      cls: "browser-favorites-file-button"
    });
    const fileInput = fileInputContainer.createEl("input", {
      attr: {
        type: "file",
        accept: ".html,.htm",
        style: "display: none;"
      }
    });
    const fileNameDisplay = fileInputContainer.createEl("div", {
      cls: "browser-favorites-filename"
    });
    fileInput.addEventListener("change", () => {
      var _a;
      const file = (_a = fileInput.files) == null ? void 0 : _a[0];
      if (file) {
        fileNameDisplay.setText(file.name);
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a2;
          const content = (_a2 = e.target) == null ? void 0 : _a2.result;
          if (typeof content === "string") {
            this.onFileUpload(content);
            this.close();
          } else {
            new import_obsidian.Notice("Unable to read file content. Please make sure it's a text file.");
          }
        };
        reader.onerror = (error) => {
          console.error("Error reading file:", error);
          new import_obsidian.Notice("Error reading file. Please try again.");
        };
        reader.readAsText(file);
      }
    });
    fileInputButton.addEventListener("click", () => {
      fileInput.click();
    });
    new import_obsidian.Setting(contentEl).addButton((button) => {
      button.setButtonText("Cancel").onClick(() => {
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BrowserFavoritesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("browser", `Browser Favorites v${PLUGIN_VERSION}`, () => {
      new import_obsidian.Notice("This plugin cannot directly access browser bookmarks due to security restrictions. Please export your bookmarks as HTML and use the import functionality.");
    });
    this.addSettingTab(new BrowserFavoritesSettingTab(this.app, this));
    this.addCommand({
      id: "import-browser-bookmarks",
      name: "Import Browser Bookmarks",
      callback: async () => {
        new FileUploadModal(this.app, (content) => {
          this.importBookmarks(content);
        }).open();
      }
    });
    this.addCommand({
      id: "cleanup-duplicates",
      name: "Cleanup Duplicate Bookmarks",
      callback: async () => {
        await this.cleanupDuplicates();
        new import_obsidian.Notice("Duplicate cleanup completed!");
      }
    });
    this.addCommand({
      id: "check-bookmarks-accessibility",
      name: "Check Bookmarks Accessibility",
      callback: async () => {
        if (!this.settings.checkAccessibility) {
          new import_obsidian.Notice("Bookmark accessibility checking is disabled. Enable it in settings first.");
          return;
        }
        new import_obsidian.Notice("Starting bookmark accessibility check...");
        await this.checkBookmarksAccessibility();
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async checkBookmarksAccessibility() {
    if (!this.settings.checkAccessibility)
      return;
    const outputFolderPath = (0, import_obsidian.normalizePath)(this.settings.outputFolderPath);
    const files = this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(outputFolderPath) && file.extension === "md"
    );
    let checkedCount = 0;
    const delay = 1e3;
    const results = {
      accessible: 0,
      inaccessible: 0,
      errors: []
    };
    async function fetchMetaInfo(url) {
      var _a, _b, _c;
      try {
        const response = await fetch(url);
        const text = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, "text/html");
        return {
          description: ((_a = doc.querySelector('meta[name="description"]')) == null ? void 0 : _a.getAttribute("content")) || ((_b = doc.querySelector('meta[property="og:description"]')) == null ? void 0 : _b.getAttribute("content")) || "",
          tags: Array.from(doc.querySelectorAll('meta[name="keywords"]')).map((el) => {
            var _a2;
            return ((_a2 = el.getAttribute("content")) == null ? void 0 : _a2.split(",")) || [];
          }).flat().map((tag) => tag.trim()).filter((tag) => tag).map((tag) => tag.startsWith("#") ? tag : `#${tag}`),
          title: ((_c = doc.querySelector("title")) == null ? void 0 : _c.textContent) || ""
        };
      } catch (error) {
        console.error("Error fetching meta info:", error);
        return { description: "", tags: [], title: "" };
      }
    }
    for (const file of files) {
      const content = await this.app.vault.read(file);
      let newContent = content;
      const lines = content.split("\n");
      let isInTable = false;
      let modifiedLines = [...lines];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith("| Title |")) {
          isInTable = true;
          modifiedLines[i] = BOOKMARK_TABLE_HEADERS.header;
          i++;
          continue;
        }
        if (isInTable && line.startsWith("|") && !line.startsWith("|--")) {
          const urlMatch = line.match(/\[ðŸ”—\]\((https?:\/\/[^\)]+)\)/);
          if (urlMatch) {
            const url = urlMatch[1];
            try {
              const metaInfo = await fetchMetaInfo(url);
              results.accessible++;
              const cells = line.split("|").map((cell) => cell.trim());
              const existingTags = cells[3] ? cells[3].split(" ") : [];
              const combinedTags = [.../* @__PURE__ */ new Set([...existingTags, ...metaInfo.tags])].join(" ");
              const existingDesc = cells[5] || "";
              const newDesc = metaInfo.description;
              const finalDesc = existingDesc || newDesc;
              const newLine = `| ${cells[1]} | ${cells[2]} | ${combinedTags} | ${cells[4]} | ${finalDesc} | ${new Date().toISOString().split("T")[0]} | \u2705 |`;
              modifiedLines[i] = newLine;
            } catch (error) {
              results.inaccessible++;
              results.errors.push({ url, error: error.message });
              const cells = line.split("|").map((cell) => cell.trim());
              const newLine = `| ${cells[1]} | ${cells[2]} | ${cells[3]} | ${cells[4]} | ${cells[5]} | ${new Date().toISOString().split("T")[0]} | \u274C |`;
              modifiedLines[i] = newLine;
            }
            checkedCount++;
            new import_obsidian.Notice(`Checking bookmarks: ${checkedCount}`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }
      const updatedContent = modifiedLines.join("\n");
      if (updatedContent !== content) {
        await this.app.vault.modify(file, updatedContent);
      }
    }
    new import_obsidian.Notice(`Accessibility check complete!
Accessible: ${results.accessible}
Inaccessible: ${results.inaccessible}`);
    console.log("Bookmark accessibility check results:", results);
    return results;
  }
  categorize(title, href) {
    const lowerTitle = title.toLowerCase();
    const lowerUrl = href.toLowerCase();
    let category = "General";
    let subcategory = "";
    const matchesKeywords = (text, keywords) => keywords.some((keyword) => text.includes(keyword));
    const categoryRules = [
      {
        category: "News",
        keywords: ["news"],
        subcategories: {
          Technology: ["tech"],
          Business: ["business"],
          Sports: ["sports", "sport"],
          Politics: ["politics", "government"]
        }
      },
      {
        category: "Reference",
        keywords: ["wiki", "wikipedia"],
        extractSubcategory: (lowerUrl2) => {
          const match = lowerUrl2.match(/wikipedia\.org\/wiki\/Category:(.+)/);
          return match ? match[1].replace(/_/g, " ").split("/")[0] : "";
        }
      },
      {
        category: "Blogs",
        keywords: ["blog"],
        subcategories: {
          Technology: ["tech", "programming"],
          Business: ["business", "economics"],
          Sports: ["sports", "sport"],
          Politics: ["politics", "government"]
        }
      },
      {
        category: "Social Media",
        keywords: ["social", "media"],
        subcategories: {
          Social: ["social", "community"],
          Media: ["media", "news"]
        }
      },
      {
        category: "Travel",
        keywords: ["travel", "tourism"],
        subcategories: {
          Food: ["food", "recipes"],
          Travel: ["travel", "tourism"]
        }
      },
      {
        category: "Entertainment",
        keywords: ["movies", "music", "games"],
        subcategories: {
          Movies: ["movies", "films", "cinema"],
          Music: ["music", "songs"],
          Gaming: ["games", "gaming"]
        }
      },
      {
        category: "Health & Wellness",
        keywords: ["health", "wellness", "fitness", "medicine"],
        subcategories: {
          Fitness: ["fitness", "exercise", "workout"],
          Medicine: ["medicine", "medical"],
          Nutrition: ["nutrition", "diet"]
        }
      },
      {
        category: "Education",
        keywords: ["learn", "education", "tutorials"],
        subcategories: {
          Tutorials: ["tutorial", "how-to"],
          Courses: ["course", "class"]
        }
      }
      // Add more categories and subcategories as needed
    ];
    for (const rule of categoryRules) {
      if (matchesKeywords(lowerTitle, rule.keywords) || matchesKeywords(lowerUrl, rule.keywords)) {
        category = rule.category;
        if (rule.subcategories) {
          for (const [subcat, subcatKeywords] of Object.entries(rule.subcategories)) {
            if (matchesKeywords(lowerTitle, subcatKeywords) || matchesKeywords(lowerUrl, subcatKeywords)) {
              subcategory = subcat;
              break;
            }
          }
        }
        if (!subcategory && rule.extractSubcategory) {
          subcategory = rule.extractSubcategory(lowerUrl);
        }
        break;
      }
    }
    return { category, subcategory };
  }
  extractTags(title, url) {
    const tags = /* @__PURE__ */ new Set();
    if (url) {
      try {
        const urlParts = new URL(url).hostname.split(".");
        if (urlParts.length > 1) {
          tags.add(`#${urlParts[urlParts.length - 2].toLowerCase()}`);
        }
      } catch (e) {
        console.error("Error parsing URL:", e);
      }
    }
    const commonKeywords = [
      "tutorial",
      "guide",
      "review",
      "documentation",
      "api",
      "tool",
      "news",
      "update",
      "tips",
      "tricks",
      "how-to",
      "reference",
      "blog",
      "opinion",
      "article",
      "resource",
      "project",
      "code"
    ];
    if (title) {
      commonKeywords.forEach((keyword) => {
        if (title.toLowerCase().includes(keyword)) {
          tags.add(`#${keyword}`);
        }
      });
    }
    return Array.from(tags);
  }
  // Neue Hilfsmethode zum Deduplizieren von Bookmarks
  deduplicateBookmarks(bookmarks) {
    const bookmarkMap = /* @__PURE__ */ new Map();
    bookmarks.forEach((bookmark) => {
      const existingGroup = bookmarkMap.get(bookmark.url) || [];
      existingGroup.push(bookmark);
      bookmarkMap.set(bookmark.url, existingGroup);
    });
    const deduplicatedBookmarks = [];
    bookmarkMap.forEach((group) => {
      const newestBookmark = group.reduce((newest, current) => {
        const newestDate = newest.addDate ? new Date(parseInt(newest.addDate) * 1e3) : new Date(0);
        const currentDate = current.addDate ? new Date(parseInt(current.addDate) * 1e3) : new Date(0);
        return currentDate > newestDate ? current : newest;
      });
      const allTags = /* @__PURE__ */ new Set();
      group.forEach((bookmark) => {
        bookmark.tags.forEach((tag) => allTags.add(tag));
      });
      newestBookmark.tags = Array.from(allTags);
      deduplicatedBookmarks.push(newestBookmark);
    });
    return deduplicatedBookmarks;
  }
  // Update der Import-Methode
  async importBookmarks(htmlContent) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, "text/html");
    const bookmarks = this.parseBookmarks(doc.body);
    const deduplicatedBookmarks = this.deduplicateBookmarks(bookmarks);
    const bookmarksByCategory = /* @__PURE__ */ new Map();
    deduplicatedBookmarks.forEach((bookmark) => {
      const category = bookmark.category || "Uncategorized";
      const subcategory = bookmark.subcategory || "General";
      if (!bookmarksByCategory.has(category)) {
        bookmarksByCategory.set(category, /* @__PURE__ */ new Map());
      }
      const categoryMap = bookmarksByCategory.get(category);
      if (!categoryMap.has(subcategory)) {
        categoryMap.set(subcategory, []);
      }
      categoryMap.get(subcategory).push(bookmark);
    });
    for (const [category, subcategories] of bookmarksByCategory) {
      for (const [subcategory, bookmarks2] of subcategories) {
        const existingUrls = await this.readExistingBookmarks(category, subcategory);
        const newBookmarks = bookmarks2.filter((bookmark) => !existingUrls.has(bookmark.url));
        if (newBookmarks.length > 0) {
          await this.appendBookmarks(category, subcategory, newBookmarks);
        }
      }
    }
    new import_obsidian.Notice(`Import completed! ${deduplicatedBookmarks.length} bookmarks processed.`);
  }
  // Methode zum Bereinigen existierender Dateien
  async cleanupDuplicates() {
    var _a;
    const outputFolderPath = (0, import_obsidian.normalizePath)(this.settings.outputFolderPath);
    const files = this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(outputFolderPath) && file.extension === "md"
    );
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let newContent = [];
      let currentSection = "";
      let bookmarksBySection = /* @__PURE__ */ new Map();
      let isInTable = false;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith("## ")) {
          currentSection = line.substring(3).trim();
          bookmarksBySection.set(currentSection, []);
          continue;
        }
        if (line.startsWith("| Title |")) {
          isInTable = true;
          continue;
        }
        if (isInTable && line.startsWith("|") && !line.startsWith("|--")) {
          const cells = line.split("|").map((cell) => cell.trim());
          const urlMatch = cells[2].match(/\[ðŸ”—\]\((https?:\/\/[^\)]+)\)/);
          if (urlMatch && currentSection) {
            const bookmark = {
              title: cells[1],
              url: urlMatch[1],
              tags: cells[3] ? cells[3].split(" ") : [],
              addDate: cells[4],
              lastModified: cells[6] || "",
              description: cells[5] || ""
            };
            (_a = bookmarksBySection.get(currentSection)) == null ? void 0 : _a.push(bookmark);
          }
        }
      }
      let headerSection = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith("# ")) {
          headerSection = line;
          newContent.push(line);
          continue;
        }
        if (line.startsWith("## ")) {
          currentSection = line.substring(3).trim();
          newContent.push("");
          newContent.push(line);
          newContent.push("");
          newContent.push(BOOKMARK_TABLE_HEADERS.header);
          const sectionBookmarks = bookmarksBySection.get(currentSection) || [];
          const deduplicatedBookmarks = this.deduplicateBookmarks(sectionBookmarks);
          deduplicatedBookmarks.forEach((bookmark) => {
            newContent.push(this.formatBookmarkLine(bookmark));
          });
          while (i < lines.length && (lines[i].startsWith("|") || lines[i].trim() === "")) {
            i++;
          }
          i--;
        }
      }
      await this.app.vault.modify(file, newContent.join("\n"));
    }
    new import_obsidian.Notice("Duplicate cleanup completed!");
  }
  async readExistingBookmarks(category, subcategory) {
    const outputFolderPath = (0, import_obsidian.normalizePath)(this.settings.outputFolderPath);
    const fileName = (0, import_obsidian.normalizePath)(path.join(outputFolderPath, `${category}.md`));
    const file = this.app.vault.getAbstractFileByPath(fileName);
    if (!file || !(file instanceof import_obsidian.TFile))
      return /* @__PURE__ */ new Set();
    const content = await this.app.vault.read(file);
    const existingUrls = /* @__PURE__ */ new Set();
    const lines = content.split("\n");
    let currentSection = "";
    for (const line of lines) {
      if (line.startsWith("## ")) {
        currentSection = line.substring(3).trim();
        continue;
      }
      if (currentSection === subcategory) {
        const urlMatch = line.match(/\[ðŸ”—\]\((https?:\/\/[^\)]+)\)/);
        if (urlMatch) {
          existingUrls.add(urlMatch[1]);
        }
      }
    }
    return existingUrls;
  }
  async appendBookmarks(category, subcategory, newBookmarks) {
    const outputFolderPath = (0, import_obsidian.normalizePath)(this.settings.outputFolderPath);
    if (!this.app.vault.getAbstractFileByPath(outputFolderPath)) {
      await this.app.vault.createFolder(outputFolderPath);
    }
    const fileName = (0, import_obsidian.normalizePath)(path.join(outputFolderPath, `${category}.md`));
    const file = this.app.vault.getAbstractFileByPath(fileName);
    const tableHeader = BOOKMARK_TABLE_HEADERS.header;
    let content = "";
    if (file instanceof import_obsidian.TFile) {
      const existingContent = await this.app.vault.read(file);
      const sections = existingContent.split(/(?=## )/);
      let subcategoryFound = false;
      content = sections.map((section) => {
        if (section.startsWith(`## ${subcategory}`)) {
          subcategoryFound = true;
          let sectionContent = `## ${subcategory}

${tableHeader}`;
          newBookmarks.forEach((bookmark) => {
            sectionContent += this.formatBookmarkLine(bookmark);
          });
          return sectionContent;
        }
        return section;
      }).join("");
      if (!subcategoryFound) {
        content += `

## ${subcategory}

${tableHeader}`;
        newBookmarks.forEach((bookmark) => {
          content += this.formatBookmarkLine(bookmark);
        });
      }
    } else {
      content = `# ${category} Bookmarks

## ${subcategory}

${BOOKMARK_TABLE_HEADERS.header}`;
      newBookmarks.forEach((bookmark) => {
        content += this.formatBookmarkLine(bookmark);
      });
    }
    if (file instanceof import_obsidian.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      await this.app.vault.create(fileName, content);
    }
  }
  // Neue Hilfsmethode zum Formatieren der Bookmark-Zeilen
  formatBookmarkLine(bookmark) {
    const formatCell = (content) => {
      if (!content)
        return "";
      return content.replace(/\|/g, "\\|").replace(/\n/g, " ").trim();
    };
    const formattedTitle = formatCell(bookmark.title);
    const formattedUrl = `[\u{1F517}](${bookmark.url})`;
    const formattedTags = formatCell(bookmark.tags.join(" "));
    const formattedDate = formatCell(bookmark.addDate || "");
    const formattedDesc = formatCell(bookmark.description || "");
    const lastCheck = "";
    const status = "";
    return `| ${formattedTitle} | ${formattedUrl} | ${formattedTags} | ${formattedDate} | ${formattedDesc} | ${lastCheck} | ${status} |
`;
  }
  parseBookmarks(element) {
    const bookmarks = [];
    const traverse = (node) => {
      var _a;
      if (node.tagName === "A") {
        const url = node.getAttribute("href");
        const title = ((_a = node.textContent) == null ? void 0 : _a.trim()) || "";
        const addDate = node.getAttribute("add_date") || "";
        const lastModified = node.getAttribute("last_modified") || "";
        if (url && title) {
          const { category, subcategory } = this.categorize(title, url);
          const tags = this.extractTags(title, url);
          bookmarks.push({
            title,
            url,
            tags,
            addDate,
            lastModified,
            description: "",
            category,
            subcategory
          });
        }
      }
      const children = Array.from(node.children);
      children.forEach((child) => {
        if (child instanceof HTMLElement) {
          traverse(child);
        }
      });
    };
    traverse(element);
    return bookmarks;
  }
};
var BrowserFavoritesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Browser Favorites Settings" });
    containerEl.createEl("h2", { text: `Browser Favorites Settings (v${PLUGIN_VERSION})` });
    new import_obsidian.Setting(containerEl).setName("Output folder").setDesc("Where to store the imported bookmarks").addText((text) => text.setPlaceholder("Browser Favorites").setValue(this.plugin.settings.outputFolderPath).onChange(async (value) => {
      this.plugin.settings.outputFolderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Check bookmark accessibility").setDesc("Periodically check if bookmarks are still accessible (may affect performance)").addToggle((toggle) => toggle.setValue(this.plugin.settings.checkAccessibility).onChange(async (value) => {
      this.plugin.settings.checkAccessibility = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("div", {
      text: `Version: ${PLUGIN_VERSION}`,
      cls: "browser-favorites-version-info"
    });
  }
};

/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

// [Previous code remains the same until the bookmark processing part]

class BrowserFavoritesPlugin extends import_obsidian.Plugin {
    // [Previous methods remain the same until categorize]

    categorize(title, href) {
        // Enhanced categorization that looks at both title and URL
        const lowerTitle = title.toLowerCase();
        const lowerUrl = href.toLowerCase();
        
        // Primary category
        let category = 'General';
        let subcategory = '';
        
        // Determine main category
        if (lowerTitle.includes('news') || lowerUrl.includes('/news/')) {
            category = 'News';
            // Determine subcategory
            if (lowerUrl.includes('tech') || lowerTitle.includes('tech')) {
                subcategory = 'Technology';
            } else if (lowerUrl.includes('business') || lowerTitle.includes('business')) {
                subcategory = 'Business';
            }
        } else if (lowerTitle.includes('wiki') || lowerUrl.includes('wikipedia')) {
            category = 'Reference';
            // Add subcategories based on Wikipedia categories if present
            const wikiMatch = lowerUrl.match(/wikipedia\.org\/wiki\/Category:(.+)/);
            if (wikiMatch) {
                subcategory = wikiMatch[1].replace(/_/g, ' ').split('/')[0];
            }
        } else if (lowerTitle.includes('blog') || lowerUrl.includes('blog')) {
            category = 'Blogs';
            // You could add subcategories based on blog topics
            if (lowerUrl.includes('tech') || lowerTitle.includes('tech')) {
                subcategory = 'Technology';
            } else if (lowerUrl.includes('food') || lowerTitle.includes('food')) {
                subcategory = 'Food';
            }
        }
        
        return { category, subcategory };
    }

    extractTags(title, url) {
        const tags = new Set();
        
        // Add tags based on URL components
        const urlParts = new URL(url).hostname.split('.');
        tags.add(urlParts[urlParts.length - 2].toLowerCase()); // Add domain name as tag
        
        // Add tags based on common keywords in title
        const commonKeywords = ['tutorial', 'guide', 'review', 'documentation', 'api', 'tool'];
        commonKeywords.forEach(keyword => {
            if (title.toLowerCase().includes(keyword)) {
                tags.add(keyword);
            }
        });
        
        return Array.from(tags);
    }

    async importBookmarks(htmlContent) {
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const links = doc.querySelectorAll('a');
            
            if (links.length === 0) {
                new import_obsidian.Notice('No bookmarks found in the file.');
                return;
            }

            const bookmarks = {};
            const stats = {
                total: 0,
                new: 0,
                existing: 0
            };

            // Process bookmarks with enhanced metadata
            for (const link of links) {
                const href = link.getAttribute('href');
                if (href && (href.startsWith('http://') || href.startsWith('https://'))) {
                    stats.total++;
                    const title = link.textContent?.trim() || 'Untitled';
                    const { category, subcategory } = this.categorize(title, href);
                    const tags = this.extractTags(title, href);
                    const addDate = link.getAttribute('add_date') || '';
                    const lastModified = link.getAttribute('last_modified') || '';
                    
                    if (!bookmarks[category]) {
                        bookmarks[category] = {};
                    }
                    if (!bookmarks[category][subcategory || 'General']) {
                        bookmarks[category][subcategory || 'General'] = new Set();
                    }
                    
                    bookmarks[category][subcategory || 'General'].add({
                        title,
                        url: href,
                        tags,
                        addDate: addDate ? new Date(parseInt(addDate) * 1000).toISOString().split('T')[0] : '',
                        lastModified: lastModified ? new Date(parseInt(lastModified) * 1000).toISOString().split('T')[0] : '',
                        description: link.getAttribute('description') || ''
                    });
                }
            }

            if (stats.total === 0) {
                new import_obsidian.Notice('No valid bookmarks found.');
                return;
            }

            // Process bookmarks by category and subcategory
            for (const category in bookmarks) {
                for (const subcategory in bookmarks[category]) {
                    const existingUrls = await this.readExistingBookmarks(category, subcategory);
                    const newBookmarks = Array.from(bookmarks[category][subcategory])
                        .filter(bookmark => !existingUrls.has(bookmark.url))
                        .sort((a, b) => a.title.localeCompare(b.title)); // Alphabetical sorting
                    
                    stats.new += newBookmarks.length;
                    stats.existing += bookmarks[category][subcategory].size - newBookmarks.length;
                    
                    if (newBookmarks.length > 0) {
                        await this.appendBookmarks(category, subcategory, newBookmarks);
                    }
                }
            }

            new import_obsidian.Notice(
                `Import complete!\nTotal: ${stats.total}\nNew: ${stats.new}\nExisting: ${stats.existing}`
            );
        } catch (error) {
            console.error('Error processing bookmarks:', error);
            new import_obsidian.Notice('Error processing bookmarks. Check console for details.');
        }
    }

    async readExistingBookmarks(category, subcategory) {
        const outputFolderPath = import_obsidian.normalizePath(this.settings.outputFolderPath);
        const fileName = import_obsidian.normalizePath(path.join(outputFolderPath, `${category}.md`));
        const file = this.app.vault.getAbstractFileByPath(fileName);
        
        if (!file) return new Set();

        const content = await this.app.vault.read(file);
        const urlRegex = /\[(.*?)\]\((https?:\/\/[^\s\)]+)\)/g;
        const existingUrls = new Set();
        
        let match;
        while ((match = urlRegex.exec(content)) !== null) {
            existingUrls.add(match[2]);
        }
        
        return existingUrls;
    }

    async appendBookmarks(category, subcategory, newBookmarks) {
        const outputFolderPath = import_obsidian.normalizePath(this.settings.outputFolderPath);

        if (!this.app.vault.getAbstractFileByPath(outputFolderPath)) {
            await this.app.vault.createFolder(outputFolderPath);
        }

        const fileName = import_obsidian.normalizePath(path.join(outputFolderPath, `${category}.md`));
        const file = this.app.vault.getAbstractFileByPath(fileName);
        
        let content = '';
        let existingContent = '';
        
        if (file) {
            existingContent = await this.app.vault.read(file);
            // Check if the subcategory section already exists
            if (!existingContent.includes(`## ${subcategory}`)) {
                content = existingContent + `\n\n## ${subcategory}\n\n`;
            } else {
                // Find the section and append to it
                const sections = existingContent.split(/(?=## )/);
                content = sections.map(section => {
                    if (section.startsWith(`## ${subcategory}`)) {
                        return section + '\n';
                    }
                    return section;
                }).join('');
            }
        } else {
            content = `# ${category} Bookmarks\n\n## ${subcategory}\n\n`;
        }

        // Append new bookmarks with enhanced formatting
        newBookmarks.forEach(bookmark => {
            let bookmarkEntry = `- [${bookmark.title}](${bookmark.url})`;
            
            // Add metadata if available
            const metadata = [];
            if (bookmark.tags.length > 0) {
                metadata.push(`Tags: ${bookmark.tags.join(', ')}`);
            }
            if (bookmark.addDate) {
                metadata.push(`Added: ${bookmark.addDate}`);
            }
            if (bookmark.description) {
                metadata.push(`Note: ${bookmark.description}`);
            }
            
            if (metadata.length > 0) {
                bookmarkEntry += `\n  - ${metadata.join(' | ')}`;
            }
            
            content += bookmarkEntry + '\n';
        });

        if (file) {
            await this.app.vault.modify(file, content);
        } else {
            await this.app.vault.create(fileName, content);
        }
    }
}

// [Rest of the code remains the same]